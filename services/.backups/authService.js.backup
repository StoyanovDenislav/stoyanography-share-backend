const bcrypt = require("bcrypt");
const { body, validationResult } = require("express-validator");
const Database = require("../Database/databaseClass");
const { generateToken, setTokenCookie } = require("../middleware/auth");
const { now, toOrientDBDateTime } = require("../utils/dateFormatter");

class AuthService {
  constructor() {
    this.dbInstance = new Database(
      process.env.DB_HOST,
      process.env.DB_PORT,
      process.env.DB_USERNAME,
      process.env.DB_PASSWORD
    );
  }

  // Validation rules for registration
  static getRegisterValidation() {
    return [
      body("username")
        .isLength({ min: 3, max: 30 })
        .withMessage("Username must be between 3 and 30 characters")
        .matches(/^[a-zA-Z0-9_]+$/)
        .withMessage(
          "Username can only contain letters, numbers, and underscores"
        ),

      body("email")
        .isEmail()
        .withMessage("Please provide a valid email address")
        .normalizeEmail(),

      body("password")
        .isLength({ min: 8 })
        .withMessage("Password must be at least 8 characters long")
        .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
        .withMessage(
          "Password must contain at least one lowercase letter, one uppercase letter, and one number"
        ),
    ];
  }

  // Validation rules for login
  static getLoginValidation() {
    return [
      body("username").notEmpty().withMessage("Username is required"),

      body("password").notEmpty().withMessage("Password is required"),
    ];
  }

  async hashPassword(password) {
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
  }

  async comparePassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
  }

  async createUser(userData) {
    const db = this.dbInstance.useDatabase(
      process.env.DB_NAME,
      process.env.DB_USERNAME,
      process.env.DB_PASSWORD
    );

    try {
      // Check if user already exists
      const existingUser = await db.query(
        "SELECT FROM User WHERE username = :username OR email = :email",
        {
          params: {
            username: userData.username,
            email: userData.email,
          },
        }
      );

      if (existingUser.length > 0) {
        throw new Error("User with this username or email already exists");
      }

      // Hash password
      const hashedPassword = await this.hashPassword(userData.password);

      // Create user record
      const result = await db.query(
        "INSERT INTO User SET username = :username, email = :email, password = :password, createdAt = :createdAt",
        {
          params: {
            username: userData.username,
            email: userData.email,
            password: hashedPassword,
            createdAt: now(),
          },
        }
      );

      return result[0];
    } catch (error) {
      throw error;
    } finally {
      this.dbInstance.closeConnection();
    }
  }

  async authenticateUser(username, password) {
    const db = this.dbInstance.useDatabase(
      process.env.DB_NAME,
      process.env.DB_USERNAME,
      process.env.DB_PASSWORD
    );

    try {
      let user = null;
      let userClass = null;

      // Try to find user in User class (Admin)
      let users = await db.query(
        "SELECT FROM User WHERE username = :username",
        { params: { username } }
      );

      if (users.length > 0) {
        user = users[0];
        userClass = "User";
      }

      // Try Photographer class if not found
      if (!user) {
        users = await db.query(
          "SELECT FROM Photographer WHERE username = :username",
          { params: { username } }
        );
        if (users.length > 0) {
          user = users[0];
          userClass = "Photographer";
        }
      }

      // Try Client class if not found
      if (!user) {
        users = await db.query(
          "SELECT FROM Client WHERE username = :username",
          { params: { username } }
        );
        if (users.length > 0) {
          user = users[0];
          userClass = "Client";
        }
      }

      // Try Guest class if not found
      if (!user) {
        users = await db.query("SELECT FROM Guest WHERE username = :username", {
          params: { username },
        });
        if (users.length > 0) {
          user = users[0];
          userClass = "Guest";
        }
      }

      if (!user) {
        throw new Error("Invalid credentials");
      }

      // Check if account is active
      if (user.isActive === false) {
        throw new Error("Account is disabled");
      }

      // Check if guest access has expired
      if (userClass === "Guest" && user.expiresAt) {
        const now = new Date();
        const expiresAt = new Date(user.expiresAt);
        if (now > expiresAt) {
          throw new Error("Guest access has expired");
        }
      }

      // Verify password
      const isValidPassword = await this.comparePassword(
        password,
        user.password
      );

      if (!isValidPassword) {
        throw new Error("Invalid credentials");
      }

      // Update last login
      await db.query(
        `UPDATE ${userClass} SET lastLogin = :lastLogin WHERE @rid = :rid`,
        {
          params: {
            lastLogin: now(),
            userId: user.userId,
          },
        }
      );

      console.log(
        `✅ User authenticated: ${username} (${userClass}, role: ${user.role})`
      );

      // Return user without password
      const { password: _, ...userWithoutPassword } = user;
      return userWithoutPassword;
    } catch (error) {
      console.error("❌ Authentication failed:", error.message);
      throw error;
    } finally {
      this.dbInstance.closeConnection();
    }
  }

  async register(req, res) {
    try {
      // Check validation results
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: errors.array(),
        });
      }

      const { username, email, password } = req.body;

      // Create user
      const newUser = await this.createUser({ username, email, password });

      // Generate JWT token with role
      const token = generateToken({
        userId: newUser.userId,
        username: newUser.username,
        email: newUser.email,
        role: newUser.role || "admin",
      });

      res.status(201).json({
        success: true,
        message: "User registered successfully",
        token,
        user: {
          id: newUser.userId,
          username: newUser.username,
          email: newUser.email,
        },
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(400).json({
        success: false,
        message: error.message || "Registration failed",
      });
    }
  }

  async login(req, res) {
    try {
      // Check validation results
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: errors.array(),
        });
      }

      const { username, password } = req.body;

      // Authenticate user
      const user = await this.authenticateUser(username, password);

      // Generate JWT token with role
      const token = generateToken({
        userId: user.userId,
        username: user.username,
        email: user.email,
        role: user.role || "admin", // Include role in token
      });

      // Set token in secure cookie
      setTokenCookie(res, token);

      res.json({
        success: true,
        message: "Login successful",
        user: {
          id: user.userId,
          username: user.username,
          email: user.email || user.encryptedEmail,
          role: user.role || "admin",
          lastLogin: user.lastLogin,
          // Include role-specific fields
          ...(user.businessName && { businessName: user.businessName }),
          ...(user.clientName && { clientName: user.clientName }),
          ...(user.guestName && { guestName: user.guestName }),
          ...(user.photographerId && { photographerId: user.photographerId }),
          ...(user.clientId && { clientId: user.clientId }),
          ...(user.expiresAt && { expiresAt: user.expiresAt }),
        },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(401).json({
        success: false,
        message: error.message || "Login failed",
      });
    }
  }

  async getProfile(req, res) {
    try {
      const db = this.dbInstance.useDatabase(
        process.env.DB_NAME,
        process.env.DB_USERNAME,
        process.env.DB_PASSWORD
      );

      const users = await db.query(
        "SELECT username, email, createdAt, lastLogin FROM User WHERE userId = :userId",
        {
          params: {
            rid: req.user.userId,
          },
        }
      );

      if (users.length === 0) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      res.json({
        success: true,
        user: users[0],
      });
    } catch (error) {
      console.error("Profile fetch error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch profile",
      });
    } finally {
      this.dbInstance.closeConnection();
    }
  }
}

module.exports = AuthService;
